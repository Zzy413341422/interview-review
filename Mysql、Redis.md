# Mysql

##  ON、WHERE、HAVING的区别

ON、WHERE、HAVING的主要差别是其子句中限制条件起作用时机引起的，ON是在生产临时表之前根据条件筛选记录，WHERE是从生产的临时表中筛选数据，而HAVING是对临时表中满足条件的数据，进行计算分组之后，通过HAVING限制语句筛选分组，返回结果是满足HAVING子句限制的分组。

## 为什么要创建索引

索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。

## 索引的种类：

唯一索引	不允许任何两行具相同值
主键索引	唯一索引的一种
普通索引	无限制
全文索引	针对较大的数据生成全文索引很耗时间空间

## 增加索引也有许多不利的一个方面:

时间方面：创建索引和维护索引要耗费时间
空间方面：索引需要占物理空间。

## 索引有哪些？聚集索引和非聚集索引的区别？

FULLTEXT，HASH，BTREE，RTREE。

- 聚集索引就是以**主键**创建的索引
- 非聚集索引就是以**非主键**创建的索引

区别：

- 聚集索引在叶子节点存储的是**表中的数据**
- 非聚集索引在叶子节点存储的是**主键和索引列**
- 使用非聚集索引查询出数据时，**拿到叶子上的主键再去查到想要查找的数据**。(拿到主键再查找这个过程叫做**回表**)

## 建立联合索引a,b,c，请问查询条件为a,c是否使用索引？a,b是否使用索引？b,a,c是否使用索引？

![å¾çæè¿°](https://segmentfault.com/img/bVUeaZ?w=778&h=377)

***最左前缀原则：***以**最左边的为起点**任何连续的索引都能匹配上

**联合索引本质：**

当创建**(a,b,c)联合索引**时，相当于创建了**(a)单列索引**，**(a,b)联合索引**以及**(a,b,c)联合索引**
想要索引生效的话,只能使用 a和a,b和a,b,c三种组合；当然，我们上面测试过，**a,c组合也可以，但实际上只用到了a的索引，c并没有用到！**

使用or：索引失效。

使用范围<>：取范围作最后一个索引。

## 为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？

![img](https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/33576849-9275-47bb-ada7-8ded5f5e7c73.png)

B+tree的磁盘读写代价低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小；
B+tree的查询效率更加稳定；
B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可；

## 什么样的字段适合建索引

唯一、不为空、经常被查询，重复字段少的字段

## 什么情况下不宜建立索引？

对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。

## 数据库引擎有哪些？InnoDB和MyIsam有啥区别?

MyISAM InnoDB MEMORY MERGE BDB；
MyISAM是非事务安全型的，而InnoDB是事务安全型的，
MyISAM锁的粒度是表级，而InnoDB支持行级锁定。
MyISAM相对简单，所以在效率上要优于InnoDB
MyISAM不支持外健，InnoDB支持。

## mysql实现事务的原理

通过redo 和 undo 日志文件实现的
undo记录了数据在事务开始之前的值
redo日志记录数据修改后的值

## 数据库的事务特性

原子性	一致性	隔离性	持久性

## 事务隔离级别

 1. 读未提交（Read Uncommitted）
    
    原理：任何操作都不加锁
    
 2. 读提交（Read Commit）

    原理：读操作不加锁，写操作加锁。读被加锁的数据时，读事务每次都读undo log中的最近版本，因此可能对同一数据读到不同的版本（不可重复读），但能保证每次都读到最新的数据。

3. 可重复读（Reapable Read）

   原理：第一次读数据的时候就将数据加行锁（共享锁），使其他事务不能修改当前数据，即可实现可重复读。但是不能锁住insert进来的新的数据，当前事务读取或者修改的同时，另一个事务还是可以insert提交，造成幻读。

4. 串行化（Serializable）

   原理：锁表，读锁和写锁阻塞。

脏读：一个事务读取了另一个事务未提交的数据；
不可重复读：不可重复读的重点是修改，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改；
幻读：幻读的重点在于新增或者删除，同样条件下两次读出来的记录数不一样。

## MVCC(多版本并发控制)

解决了两个事务在提交读、可重复读两个隔离级别下读同一行和写同一行的并发。

在每一行数据中额外保存两个隐藏的列：create version和delete version

插入数据：记录的版本号即当前事务的版本号

更新操作：采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新的记录的方式。

删除操作：把事务版本号作为删除版本号。

查询操作：(1)删除版本号未指定或者大于当前事务版本号(2)创建版本号小于或者等于当前事务版本号

## 数据库锁粒度大会引发什么问题

![img](https://user-gold-cdn.xitu.io/2018/7/23/164c6d7ae44d8ac6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 对于`UPDATE、DELETE、INSERT`语句，**InnoDB**会**自动**给涉及数据集加排他锁（X)

  **MyISAM**在执行查询语句`SELECT`前，会**自动**给涉及的所有表加**读锁**，在执行更新操作（`UPDATE、DELETE、INSERT`等）前，会**自动**给涉及的表加**写锁**，这个过程并**不需要用户干预**

- 共享锁（S）：`SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE`。

- 排他锁（X）：`SELECT * FROM table_name WHERE ... FOR UPDATE`。

- 间隙锁  :SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;

允许多个线程同时对想读的内容加锁,即共享锁或叫S锁),写的时候不*能*读

InnoDB实现的`Repeatable read`隔离级别配合GAP间隙锁已经避免了幻读！

- 乐观锁其实是一种思想，正如其名：认为不会锁定的情况下去更新数据，如果发现不对劲，才不更新(回滚)。在数据库中往往添加一个version字段来实现。
- 悲观锁用的就是数据库的行锁，认为数据库会发生并发冲突，直接上来就把数据锁住，其他事务不能修改，直至提交了当前事务

## 外连接

外连接：left join，right join

内连接：inner join（只显示满足条件的）

全连接：full join（满足的和不满足的都显示）

交叉连接：cross join（笛卡尔积）

## 表的范式的三大范式

第一范式（1NF）确保每列保持原子不可再分。
第二范式（2NF）属性完全依赖于主键：依赖于主键（联合主键）的一部分。
第三范式（3NF）属性不依赖于其它非主属性 ：依赖于非主键列。

## 查询前n名的sql语句

select a.s_id,a.c_id,a.s_score from score a 
where (select COUNT(1) from score b where b.c_id=a.c_id and b.s_score>=a.s_score)<=2 ORDER BY a.c_id

## limit 20000，10如何优化

SELECT id,title,content **FROM** items **WHERE** id IN (**SELECT** id **FROM** items **ORDER** **BY** id limit 900000, 10);  

## 本月，今日查询

```sql
本月：
SELECT * FROM 表名 WHERE DATE_FORMAT( 时间字段名, ‘%Y%m’ ) = DATE_FORMAT( CURDATE( ) , ‘%Y%m’ )
昨天：
SELECT * FROM 表名 WHERE TO_DAYS( NOW( ) ) - TO_DAYS( 时间字段名) <= 1
```

## 一个 SQL 执行的很慢的原因

怎么发现有问题的SQL?（通过MySQL慢查询日志对有效率问题的SQL进行监控）

通过explain查询和分析SQL的执行计划

1、大多数情况下很正常，偶尔很慢，则有如下原因

(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。

(2)、执行的时候，遇到锁，如表锁、行锁。

2、这条 SQL 语句一直执行的很慢，则有如下原因。

(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。

(2)、数据库选错了索引。

## explain的type类型


const
查找主键索引，返回的数据至多一条（0或者1条）。 属于精确查找

eq_ref
查找唯一性索引，返回的数据至多一条。属于精确查找


ref
查找非唯一性索引，返回匹配某一条件的多条数据。属于精确查找、数据返回可能是多条


range
查找某个索引的部分索引，一般在where子句中使用 < 、>、in、between等关键词。只检索给定范围的行，属于范围查找


index
查找所有的索引树，比ALL要快的多，因为索引文件要比数据文件小的多。


ALL
不使用任何索引，进行全表扫描，性能最差。

## SQL优化

第一优化你的sql和索引；

第二加缓存，memcached,redis；

第三以上都做了后，还是慢，就做主从复制，读写分离

第四如果以上都做了还是慢，不要想着去做切分，mysql自带分区表，先试试这个，对你的应用是透明的，无需更改代码,但是sql语句是需要针对分区表做优化的，sql条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，另外分区表还有一些坑，在这里就不多说了；

第五如果以上都做了，那就先做垂直拆分，其实就是根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；

第六才是水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key,为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；

## 读写分离

主从复制原理：主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。

## MySQL的delete,drop与truncate区别？

drop	表级的删除；
truncate	清空表；
delete	配合where删除数据；

## MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义

#### (1)、varchar与char的区别

char是一种固定长度的类型，varchar则是一种可变长度的类型

#### (2)、varchar(50)中50的涵义

最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)

#### (3)、int（20）中20的涵义

是指显示字符的长度
但要加参数的，最大为255，比如它是记录行数的id,插入10笔资料，它就显示00000000001 ~~~00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加0
20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；

## 有多少种日志?

错误日志：记录出错信息，也记录一些警告信息或者正确的信息。
查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。
二进制日志：记录对数据库执行更改的所有操作。
慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。
事务日志：

## 存储过程和触发器

存储过程：类似创建一个方法，带有参数，储存多条sql语句，在sql中调用。

触发器：创建一个事件在指定的“频率”，当“增删改”的“之前或之后”去执行。

# Redis

## 什么是Redis？

Redis本质上是一个Key-Value类型的内存数据库,因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。

## Redis相比memcached有哪些优势?

(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
(2) redis的速度比memcached快很多
(3) redis可以持久化其数据

## Redis和mongoDB区别？

(1)mongoDb文档型数据数据库，可以存储海量数据

(2)redis使用纯内存操作，速度更好；mongoDB也可以将热点数据映射到内存；

(3)都支持事务

## Redis支持哪几种数据类型？ 

String: set,get,decr,incr,mget
List: lpush,rpush,lpop,rpop,lrange（双向链表）
hash : hget,hset,hgetall		（HashMap）
Set												(HashSet)
Sorted Set					  			 (HashMap和SkipList)

## Redis有哪几种数据淘汰策略？ 

noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
allkeys-random: 回收随机的键使得新添加的数据有空间存放。
volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。

## 一个字符串类型的值能存储最大容量是多少**？** 

512M

## 为什么Redis需要把所有数据放到内存中 

Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。
所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。

## MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？ 

redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。 

## **Redis**有哪些适合的场景**？**

（1）会话缓存（Session Cache）
（2）全页缓存（FPC）
（3）消息队列
Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。
（4）排行榜/计数器
（5）发布/订阅
最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！

## 普通哈希

先对key进行哈希。得到哈希结果在取模。然后根据取模结果，去对应的服务器上，找到这个key对应的value。

缺点：扩容后映射关系大量失效。

## 哈希一致性

在0-最大正整数 的一个环中，将key的哈希结果放到环中，在顺时针的第一个服务器存放数据。

缺点：要保证服务器节点均匀分布在哈希环上

## 哈希槽

一共有16384个槽，每台服务器分管其中的一部分，插入一个数据的时候，将key的哈希结果对16384取余，确定将数据放到哪个槽里面

当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；

## 怎么测试Redis的连通性？

ping

## **Redis**事务相关的命令有哪几个**？**

MULTI(开启事务)EXEC(提交)DISCARD(回滚) 

## **Redis key**的过期时间和永久有效分别怎么设置？

expire persist

## **Redis**如何做内存优化？

尽可能使用散列表（hashes），hashes使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。

## **Redis**回收进程如何工作的？

一个客户端运行了新的命令，添加了新的数据。
Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。
一个新的命令被执行，等等。

## 缓存雪崩和缓存穿透问题解决方案

### 缓存雪崩

简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。
解决：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。


### 缓存穿透

简介：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。
解决办法： 如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

## 快照（snapshotting）持久化（RDB）

Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。

## AOF（append-only file）持久化

开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。

## redis发布订阅模式

多个客户端sub订阅频道，一个客户端往频道发送信息。

## 使用过Redis做异步队列么，你是怎么用的？

一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。

## redis如何实现延时队列？

ZRANGEBYSCORE list min max

## redis如何实现排行榜？

zadd list A score;

zrevrange list 0 -1 with scores;

zincrby list score A;

## 是否使用过Redis集群，集群的原理是什么？

Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。



