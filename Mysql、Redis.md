# Mysql

##  在使用left jion时，on和where条件的区别如下：

1、 on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。

2、where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。

## 为什么要创建索引:

索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。

## 索引的种类：

唯一索引	不允许任何两行具相同值
主键索引	唯一索引的一种
普通索引	无限制
全文索引	针对较大的数据生成全文索引很耗时间空间

## 增加索引也有许多不利的一个方面:

时间方面：创建索引和维护索引要耗费时间
空间方面：索引需要占物理空间。

## 索引有哪些？聚集索引和非聚集索引的区别？

FULLTEXT，HASH，BTREE，RTREE。

- 聚集索引就是以**主键**创建的索引
- 非聚集索引就是以**非主键**创建的索引

区别：

- 聚集索引在叶子节点存储的是**表中的数据**
- 非聚集索引在叶子节点存储的是**主键和索引列**
- 使用非聚集索引查询出数据时，**拿到叶子上的主键再去查到想要查找的数据**。(拿到主键再查找这个过程叫做**回表**)

## 建立联合索引a,b,c，请问查询条件为a,c是否使用索引？a,b是否使用索引？b,a,c是否使用索引？

***最左前缀原则：***以**最左边的为起点**任何连续的索引都能匹配上

**联合索引本质：**

当创建**(a,b,c)联合索引**时，相当于创建了**(a)单列索引**，**(a,b)联合索引**以及**(a,b,c)联合索引**
想要索引生效的话,只能使用 a和a,b和a,b,c三种组合；当然，我们上面测试过，**a,c组合也可以，但实际上只用到了a的索引，c并没有用到！**

使用or：索引失效。

使用范围<>：取范围作最后一个索引。

## 为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？

![img](https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/33576849-9275-47bb-ada7-8ded5f5e7c73.png)

B+tree的磁盘读写代价低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小；
B+tree的查询效率更加稳定；
由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可；

## 什么样的字段适合建索引

唯一、不为空、经常被查询的字段

## 什么情况下不宜建立索引？

对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。

## 说说b树和b+树，画画b+树的结构，b+树最下面存的是数据吗？下面的数据有序吗？

聚簇索引是数据，否则不是，有序

## 数据库引擎有哪些？InnoDB和MyIsam有啥区别?

MyISAM InnoDB MEMORY MERGE NDB；
MyISAM是非事务安全型的，而InnoDB是事务安全型的，
MyISAM锁的粒度是表级，而InnoDB支持行级锁定。
MyISAM相对简单，所以在效率上要优于InnoDB
MyISAM不支持外健，InnoDB支持。

## mysql实现事务的原理

通过redo 和 undo 日志文件实现的
undo记录了数据在事务开始之前的值
redo日志记录数据修改后的值

## 数据库的事务特性，隔离级别, 分别解决什么问题

原子性	一致性	隔离性	持久性
未提交读	提交读	可重复读	可串行化	
脏读：一个事务读取了另一个事务未提交的数据；
不可重复读：不可重复读的重点是修改，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改；
幻读：幻读的重点在于新增或者删除，同样条件下两次读出来的记录数不一样。

## MVCC(多版本并发控制)

InnoDB**基于行锁**还实现了MVCC多版本并发控制,MVCC主要适用于Mysql的RC,RR隔离级别

在每一行数据中额外保存两个隐藏的列：create version和delete version

插入数据：记录的版本号即当前事务的版本号

更新操作：采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新的记录的方式。

删除操作：把事务版本号作为删除版本号。

查询操作：(1)删除版本号未指定或者大于当前事务版本号(2)创建版本号小于或者等于当前事务版本号

## 数据库锁粒度大会引发什么问题

![img](https://user-gold-cdn.xitu.io/2018/7/23/164c6d7ae44d8ac6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 对于`UPDATE、DELETE、INSERT`语句，**InnoDB**会**自动**给涉及数据集加排他锁（X)

  **MyISAM**在执行查询语句`SELECT`前，会**自动**给涉及的所有表加**读锁**，在执行更新操作（`UPDATE、DELETE、INSERT`等）前，会**自动**给涉及的表加**写锁**，这个过程并**不需要用户干预**

- 共享锁（S）：`SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE`。

- 排他锁（X)：`SELECT * FROM table_name WHERE ... FOR UPDATE`。

- 间隙锁  :SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;

允许多个线程同时对想读的内容加锁,即共享锁或叫S锁),写的时候不*能*读

InnoDB实现的`Repeatable read`隔离级别配合GAP间隙锁已经避免了幻读！

- 乐观锁其实是一种思想，正如其名：认为不会锁定的情况下去更新数据，如果发现不对劲，才不更新(回滚)。在数据库中往往添加一个version字段来实现。
- 悲观锁用的就是数据库的行锁，认为数据库会发生并发冲突，直接上来就把数据锁住，其他事务不能修改，直至提交了当前事务

## 外连接

## 查询前n名的sql语句

select a.s_id,a.c_id,a.s_score from score a 
where (select COUNT(1) from score b where b.c_id=a.c_id and b.s_score>=a.s_score)<=2 ORDER BY a.c_id

## limit 20000，10如何优化

SELECT id,title,content **FROM** items **WHERE** id IN (**SELECT** id **FROM** items **ORDER** **BY** id limit 900000, 10);  

## 一个 SQL 执行的很慢的原因

1、大多数情况下很正常，偶尔很慢，则有如下原因

(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。

(2)、执行的时候，遇到锁，如表锁、行锁。

2、这条 SQL 语句一直执行的很慢，则有如下原因。

(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。

(2)、数据库选错了索引。

## SQL语句及索引的优化

#### (1). SQL语句的优化

SQL语句的优化主要包括三个问题，即如何发现有问题的SQL、如何分析SQL的执行计划以及如何优化SQL，下面将逐一解释。

##### a. 怎么发现有问题的SQL?（通过MySQL慢查询日志对有效率问题的SQL进行监控）

MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10s以上的语句。慢查询日志的相关参数如下所示：

##### b. 通过explain查询和分析SQL的执行计划

　　使用 EXPLAIN 关键字可以知道MySQL是如何处理你的SQL语句的，以便分析查询语句或是表结构的性能瓶颈。通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及每张表有多少行被优化器查询等问题。当扩展列extra出现Using filesort和Using temporay，则往往表示SQL需要优化了。

##### c. SQL语句的优化

优化insert语句：一次插入多值；
应尽量避免在 where 子句中使用 like ‘%输入符’

#### (2).索引优化

　　建议在经常作查询选择的字段、经常作表连接的字段以及经常出现在order by、group by、distinct 后面的字段中建立索引。但必须注意以下几种可能会引起索引失效的情形：
%输入符%’
OR语句前后没有同时使用索引；
对于多列索引，必须满足最左匹配原则

#### (3). 数据库表结构的优化

数据库表结构的优化包括选择合适数据类型、表的范式的优化、表的垂直拆分和表的水平拆分等手段。

##### a.选择合适数据类型

使用较小的数据类型解决问题；
使用简单的数据类型(mysql处理int要比varchar容易)；
尽可能的使用not null 定义字段；
尽量避免使用text类型，非用不可时最好考虑分表；

##### b. 表的范式的优化

一般情况下，表的设计应该遵循三大范式。

第一范式（1NF）无重复的列
第二范式（2NF）属性完全依赖于主键
第三范式（3NF）属性不依赖于其它非主属性

##### c.分库分表

###### 主键生成策略：
Sequence ID  ：数字ID
UUID ：128位的字符串ID
Snowflake：用64位的长整型代替128位的字符串

#### d.读写分离

主从复制原理：主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。

#### (4). 硬件的优化

CPU：核心数多并且主频高的
内存：增大内存
磁盘配置和选择：磁盘性能

#### (5). 数据库连接池优化

如果当前正在使用的连接数没有达到maxActive，则判断当前是否空闲连接，如果有则直接使用空闲连接，如果没有则新建立一个连接
initialSize	3	初始化配置
minIdle	3	最小连接数
maxActive	15	最大连接数

## MySQL的delete,drop与truncate区别？

drop	表级的删除；不能回滚；
truncate	清空表；不记录单行删除日志；无法恢复；只能对于TABLE操作；不能在带FOREIGN KEY约束的表（被引用的表）中使用；计数从头开始；
delete	配合where删除数据；会记录日志用于回归；会触发触发器；不减少索引和表的空间；

## MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义

#### (1)、varchar与char的区别

char是一种固定长度的类型，varchar则是一种可变长度的类型

#### (2)、varchar(50)中50的涵义

最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)

#### (3)、int（20）中20的涵义

是指显示字符的长度
但要加参数的，最大为255，比如它是记录行数的id,插入10笔资料，它就显示00000000001 ~~~00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加0
20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；

## 有多少种日志?

错误日志：记录出错信息，也记录一些警告信息或者正确的信息。
查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。
二进制日志：记录对数据库执行更改的所有操作。
慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。
事务日志：

# Redis

## 什么是Redis？

Redis本质上是一个Key-Value类型的内存数据库,因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。

## Redis相比memcached有哪些优势?

(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
(2) redis的速度比memcached快很多
(3) redis可以持久化其数据

## Redis和mongoDB区别？

(1)mongoDb文档型数据数据库，可以存储海量数据

(2)redis使用纯内存操作，速度更好；mongoDB也可以将热点数据映射到内存；

(3)都支持事务

## Redis支持哪几种数据类型？ 

String: set,get,decr,incr,mget
List: lpush,rpush,lpop,rpop,lrange
hash : hget,hset,hgetall
Set、Sorted Set、

## zset数据结构

![img](https://img-blog.csdn.net/20160131083150090)

1.ziplist，压缩双向链表
2.skiplist,跳表实现

## Redis有哪几种数据淘汰策略？ 

noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
allkeys-random: 回收随机的键使得新添加的数据有空间存放。
volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。

## 一个字符串类型的值能存储最大容量是多少**？** 

512M

## 为什么Redis需要把所有数据放到内存中 

Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。
所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。

## MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？ 

redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。 

## **Redis**有哪些适合的场景**？**

（1）会话缓存（Session Cache）
（2）全页缓存（FPC）
（3）消息队列
Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。
（4）排行榜/计数器
（5）发布/订阅
最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！

## 说说Redis哈希槽的概念？ 

Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。

## 怎么测试Redis的连通性？

ping

## **Redis**事务相关的命令有哪几个**？**

MULTI(开启事务)EXEC(提交)DISCARD(回滚) 

## **Redis key**的过期时间和永久有效分别怎么设置？

expire persist

## **Redis**如何做内存优化？

尽可能使用散列表（hashes），hashes使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。

## **Redis**回收进程如何工作的？

一个客户端运行了新的命令，添加了新的数据。
Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。
一个新的命令被执行，等等。

## 缓存雪崩和缓存穿透问题解决方案

### 缓存雪崩

简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。
解决：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。


### 缓存穿透

简介：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。
解决办法： 如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

## 快照（snapshotting）持久化（RDB）

Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。

## AOF（append-only file）持久化

开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。

## 使用过Redis做异步队列么，你是怎么用的？

一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。

## redis如何实现延时队列？

ZRANGEBYSCORE list min max

## redis如何实现排行榜？

zadd list A score;

zrevrange list 0 -1 with scores;

zincrby list score A;

## 是否使用过Redis集群，集群的原理是什么？

Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。



