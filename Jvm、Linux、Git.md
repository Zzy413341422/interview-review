# J2EE

## JavaWeb三大组件（Servlet、Filter、Listener）

1、Servlet 
Servlet是用来处理客户端请求的动态资源

2、Filter 

filter主要负责拦截请求

3、Listener 

Listener就是监听器，它可以监听Application、Session、Request对象，当这些对象发生变化就会调用对应的监听方法。 

## Listener,Filter,Servlet执行顺序

listener->Filter->servlet(理发师)

## Servlet生命周期

Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法。

## Jsp和Servlet什么关系

JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。

# Jvm虚拟机

## JVM加载代码的一个流程

## 介绍下Java内存区域。

![img](https://camo.githubusercontent.com/a66819fd82c6adfa69b368edf3c52b1fa9cdc89d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67)

- Java堆：占据了虚拟机管理内存中最大的一块（没想到吧），唯一目的就是存放对象实例（与引用是两个概念），也是垃圾回收器主要管理的地方 

- 方法区：存储加载的类信息、常量区、静态变量、JIT（即时编译器）处理后的数据等，类的信息包含类的版本、字段、方法、接口等信息。需要注意是常量池就在方法区中，也是我们这次需要关注的地方。
  JDK1.7中JVM把String常量区从方法区中移除了；JDK1.8中JVM把String常量池移入了堆中

- ```java
  String str1 = "str";
  		  String str2 = "ing";
  		  
  		  String str3 = "str" + "ing";//常量池中的对象
  		  String str4 = str1 + str2; //在堆上创建的新的对象	  
  		  String str5 = "string";//常量池中的对象
  		  System.out.println(str3 == str4);//false
  		  System.out.println(str3 == str5);//true
  		  System.out.println(str4 == str5);//false
  ```

  ## 对象的访问定位的两种方式

  ![å¯¹è±¡çè®¿é®å®ä½-ä½¿ç¨å¥æ](https://camo.githubusercontent.com/04c82b46121149c8cc9c3b81e18967a5ce06353f/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352541462542392545382542312541312545372539412538342545382541452542462545392539372541452545352541452539412545342542442538442d2545342542442542462545372539342541382545352538462541352545362539462538342e706e67)

  ![å¯¹è±¡çè®¿é®å®ä½-ç´æ¥æé](https://camo.githubusercontent.com/0ae309b058b45ee14004cd001e334355231b2246/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352541462542392545382542312541312545372539412538342545382541452542462545392539372541452545352541452539412545342542442538442d2545372539422542342545362538452541352545362538432538372545392539322538382e706e67)

## 如何判断对象是否死亡（两种方法）。

引用计数法: 给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。
可达性分析算法:通过一系列的称为 “GC Roots” 的对象作为起点,当一个对象到GC Roots没有任何引用链相连的话，则证明此对象是不可用的。

GC Roots：

1.栈中引用的对象；

2.方法区中的静态，常量引用对象；

3.本地方法栈中引用的对象；

##  简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。

![](C:\Users\admin\Pictures\Camera Roll\34.png)

#### 1．强引用

垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

#### 2．软引用（SoftReference）

如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

#### 3．弱引用（WeakReference）

一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

#### 4．虚引用（PhantomReference）

"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

## 垃圾收集有哪些算法，各自的特点？

标记-清除算法
复制算法
标记-整理算法
分代收集算法

## HotSpot为什么要分为新生代和老年代？

这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。

## 堆内存分配策略

![å åå­å¸¸è§åéç­ç¥ ](https://camo.githubusercontent.com/6b0bb14d82c24d5d4b0302c69a11589b3d887adc/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352541302538362545352538362538352545352541442539382e6a7067)

## 什么对象进入老年代：

1.大对象；

2.长期存活的对象；

3.相同年龄的对象占了survivor空间的一半

## 并行和并发：

收集器中的并行（Parallel）语义：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态
收集器中的并发（Concurrent）语义：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序于另一个CPU上。

## 介绍一下收集器。

![img](https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3841264175,3663926521&fm=15&gp=0.jpg)

•  Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效； 
•  Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本； 
•  ParNew收集器 (复制算法):新生代并行收集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现； 
•  Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。
•  Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本； 
•  CMS(Concurrent Mark Sweep)收集器（标记-清除算法）：老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。 
•  G1(Garbage First)收集器 (标记-整理算法)：Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。

![img](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1561827132&di=e409b6bd14bb4bc312c36c6227b9c9c7&imgtype=jpg&er=1&src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F1591870%2F201903%2F1591870-20190317160744429-966296736.png)

## Minor Gc和Full GC 有什么不同呢？

Minor GC:从年轻代空间（包括 Eden 和 Survivor 区域）回收内存
Major GC:只收集old gen
Full GC:收集整个堆

## 什么时候触发MinorGC?什么时候触发FullGC?

Minor GC：

当Eden区和From Survivor区满时；

Full GC：

调用System.gc时，系统建议执行Full GC，但是不必然执行

老年代空间不足

方法区空间不足

## 简单说说类加载过程，里面执行了哪些操作？

加载、验证、准备、解析、初始化、使用和卸载

## 对类加载器有了解吗？什么是双亲委派模型？

![ClassLoader](https://camo.githubusercontent.com/4311721b0968c1b9fd63bdc0acf11d7358a52ff6/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f636c6173736c6f616465725f5750532545352539422542452545372538392538372e706e67)

## 双亲委派模型的工作过程以及使用它的好处。

采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。

## 如何破坏双亲委派模型

1：自己写一个类加载器	2：重写loadclass方法(打破模型)	3：重写findclass方法(自定义类加载器不打破模型)

## Jvm调优

-Xms:初始堆大小
-Xmx:最大堆大小
-XX:NewSize=n:设置年轻代大小
-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4
-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5
-XX:MaxPermSize=n:设置持久代大小

#### 调优工具：

Jstack，Jps，Jconsole 与 Visual VM；

| 空间   | 命令行选项                      | 占用倍数                            |
| ------ | ------------------------------- | ----------------------------------- |
| Java堆 | -Xms和-Xmx                      | 3~4倍FullGC后的老年代空间占用量     |
| 永久代 | -xx：PermSize和-xx：MaxPermSize | 1.2~1.5倍FullGC后的永久代空间占用量 |
| 新生代 | -Xmn                            | 1~1.5倍FullGC后的老年代空间占用量   |
| 老年代 | Java堆大小减新生代大小          | 2~3倍FullGC后的老年代空间占用量     |

# Linux

## 常用目录：

/etc/   系统范围内的配置文件。

/home/	用户的家目录，包含保存的文件、个人设置等，一般为单独的分区。

/proc/	虚拟文件系统

/sbin/	必要的系统二进制文件，普通用户不能执行

/usr/		包含绝大多数的(多)用户工具和应用程序。

/var/		变量文件

## 常用命令：

#### 目录切换命令

`cd /`： 切换到系统根目录

`cd ~`： 切换到用户主目录

#### 目录的操作命令（增删改查）

`mkdir 目录名称`： 增加目录

`ls或者ll`（ll是ls -l的缩写，ll命令以看到该目录下的所有目录和文件的详细信息）：查看目录信息

`find 目录 参数`： 寻找目录（查）

mv 目录名称 目录的新位置： 移动目录的位置---剪切（改）

注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。

cp -r 目录名称 目录拷贝的目标位置： 拷贝目录（改），-r代表递归拷贝

rm [-rf] 目录: 删除目录（删）

chown：利用 chown 将指定文件的拥有者改为指定的用户或组   
chmod：Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用，r=4，w=2，x=1；

#### 文件的操作命令

`touch 文件名称`: 文件的创建（增）

cat/more/less/tail 文件名称 文件的查看（查）

注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化

`cat`： 只能显示最后一屏内容

`more`： 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看

`less`： 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看

`tail-10` ： 查看文件的后10行，Ctrl+C结束

vim 文件： 修改文件的内容（改）

vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。

rm -rf 文件： 删除文件（删）

#### 压缩文件的操作命令

打包并压缩文件： tar -zcvf 打包压缩后的文件名 要打包压缩的文件

解压压缩包：tar -xvf test.tar.gz

#### 其他常用命令

ps -ef|grep ~~~

kill -p ~~

top P,M

查看linux操作系统磁盘空间命令：df

查看某个端口是否被使用 lsof -i:6379

















