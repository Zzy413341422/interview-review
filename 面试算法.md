## 树

#### 遍历递归

```
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        traversal(root, list);
        return list;
    }

    private void traversal(TreeNode node, List<Integer> list) {
        if (node != null) {
            traversal(node.left, list);
            traversal(node.right, list);
        }
    }
```

#### 非递归遍历（前序和中序）

```
	List<Integer> traverse(TreeNode root) {
        Stack<TreeNode> stack = new Stack();
        List<Integer> list = new ArrayList<>();
        while (!stack.isEmpty() || root != null) {
            if (root != null) {
                //                前序遍历
                //                list.add(root.val);
                stack.push(root);
                root = root.left;
            } else {
                root = stack.pop();
                //                中序遍历
                //                list.add(root.val);
                root = root.right;
            }
        }
        return list;
    }
```

#### 非递归后序遍历

```
	void postTraverse(TreeNode node) {
        Stack<TreeNode> s1 = new Stack<TreeNode>();
        //创建栈s2的目的在于记住每个访问的节点
        Stack<Integer> s2 = new Stack<Integer>();
        //如果栈s2的栈顶是1，标识当前访问的节点
        while (node != null || !s1.isEmpty()) {
            while (node != null) {
                s1.push(node);
                s2.push(0);
                node = node.left;
            }
            //这个循坏的目的是对栈s2栈顶为1时对应的栈s1的栈顶元素进行访问
            while (!s1.isEmpty() && s2.peek().equals(1)) {
                s2.pop();
                s1.pop();
            }
            //访问左子树到头后，就可以访问其右孩子了
            if (!s1.isEmpty()) {
                s2.pop();
                s2.push(1);
                node = s1.peek();
                node = node.right;
            }
        }
    }
```
#### 分层遍历

```
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> lists = new ArrayList<>();
        if (root == null) return lists;
        Queue<TreeNode> nodes = new LinkedList<>();
        nodes.add(root);
        while (!nodes.isEmpty()) {
            int num = nodes.size();
            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < num; i++) {
                TreeNode node = nodes.remove();
                list.add(node.val);
                if (node.left != null) nodes.add(node.left);
                if (node.right != null) nodes.add(node.right);
            }
            lists.add(list);
        }
        return lists;
    }
```

#### 完全二叉树检验

```
    public boolean isCompleteTree(TreeNode root) {
        LinkedList<TreeNode> list=new LinkedList<>();
        list.add(root);
        TreeNode cur;
        while ((cur=list.removeFirst())!=null){
            list.addLast(cur.left);
            list.addLast(cur.right);
        }
        while (!list.isEmpty()){
            cur=list.removeFirst();
            if (cur!=null) return false;
        }
        return true;
    }
```
#### 完全二叉树的节点个数

```
    public int countNodes(TreeNode root) {
        return root==null?0:countNodes(root.left) + countNodes(root.right) + 1;
    }
```
#### 平衡二叉树检验

```
    public boolean isBalanced(TreeNode root) {
        if (root==null) return true;
        int i = isBalancedDFS(root);
        if (i>=20000) return false;
        return true;
    }
    public int isBalancedDFS(TreeNode root) {
        if (root==null) return 0; 
        if (Math.abs(isBalancedDFS(root.left)-isBalancedDFS(root.right))>1) return 20000;
        return Math.max(isBalancedDFS(root.left),isBalancedDFS(root.right))+1;
    }
```
#### 二叉树最大深度

```
    public int maxDepth(TreeNode root) {
        return root==null?0:Math.max(maxDepth(root.left), maxDepth(root.right))+1;
    }
```
#### 二叉树最大宽度

```
    private int maxW = 0;
    
    public int widthOfBinaryTree(TreeNode root) {
        dfs(root, 1, 1, new ArrayList<>());
        return maxW;
    }
    
    private void dfs(TreeNode r, int level, int index, List<Integer> left) {
        if(r == null) return;
        if(level > left.size()) left.add(index);
        maxW = Math.max(maxW, index - left.get(level-1) + 1);
        dfs(r.left, level+1, index*2, left);
        dfs(r.right, level+1, index*2+1, left);
    }
```
#### 二叉树中的最大路径和

```
    private int ret = Integer.MIN_VALUE;
    
    public int maxPathSum(TreeNode root) {
        getMax(root);
        return ret;
    }
    
    private int getMax(TreeNode r) {
        if(r == null) return 0;
        int left = Math.max(0, getMax(r.left)); 
        int right = Math.max(0, getMax(r.right));
        ret = Math.max(ret, r.val + left + right);
        return Math.max(left, right) + r.val;
    }
```
#### 二叉树最小深度

```
   public int minDepth(TreeNode root) {
        if (root==null) return 0;
        if (root.right==null||root.left==null){
            return Math.max(minDepth(root.left),minDepth(root.right))+1;
        }
        return Math.min(minDepth(root.left),minDepth(root.right))+1;
    }
```
#### 二叉树的最近公共祖先

```
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root==null||root==p||root==q) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if (left!=null&&right!=null) return root;
        return left==null?right:left;
    }
```
#### 相同的树

```
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (q==null&&p==null) return true;
        if (q!=null&&p!=null&&p.val==q.val){
            return isSameTree(q.left,p.left)&&isSameTree(q.right,p.right);
        }else {
            return false;
        }
    }
```
#### 对称二叉树

```
    public boolean isSymmetric(TreeNode root) {
        if(root==null) return true;
        return isSymmetrical(root.left,root.right);
    }
    boolean isSymmetrical(TreeNode r1,TreeNode r2) {
        if (r1==null&&r2==null) return true;
        else if (r1==null||r2==null) return false;
        return r2.val==r1.val&&isSymmetrical(r1.left,r2.right)&&isSymmetrical(r1.right,r2.left);
    }
```
#### 从前序与中序遍历序列构造二叉树

```
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return dfs(preorder,0,preorder.length-1,inorder,0,inorder.length-1);
    }

    private TreeNode dfs(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) {
        if (preStart>preEnd||inStart>inEnd) return null;
        TreeNode root=new TreeNode(preorder[preStart]);
        for (int i=inStart;i<=inEnd;i++){
            if (inorder[i]==preorder[preStart]){
                root.left=dfs(preorder,preStart+1,preStart+i-inStart,inorder,inStart,i-1);
                root.right=dfs(preorder,preStart+i-inStart+1,preEnd,inorder,i+1,inEnd);
                break;
            }
        }
        return root;
    }
```
#### 从中序与后序遍历序列构造二叉树

```
     public TreeNode buildTree(int[] inorder, int[] postorder) {
        return dfs(inorder,0,inorder.length-1,postorder,0,postorder.length-1);
    }

    private TreeNode dfs(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) {
        if (inStart>inEnd||postStart>postEnd) return null;
        TreeNode root=new TreeNode(postorder[postEnd]);
        for (int i=inStart;i<=inEnd;i++){
            if (inorder[i]==postorder[postEnd]){
                root.left=dfs(inorder,inStart,i-1,postorder,postStart,postStart+i-1-inStart);
                root.right=dfs(inorder,i+1,inEnd,postorder,postStart+i-inStart,postEnd-1);
            }
        }
        return root;
    }
```
#### 将有序数组转换为二叉搜索树

```
   public TreeNode sortedArrayToBST(int[] nums) {
        if (nums.length==0) return null;
        return sortedArrayToBST(nums,0,nums.length-1);
    }
    TreeNode sortedArrayToBST(int[] nums,int start,int end){
        if (start>end) return null;
        int mid=(start+end)/2;
        TreeNode treeNode = new TreeNode(nums[mid]);
        treeNode.left = sortedArrayToBST(nums,start,mid - 1);
        treeNode.right = sortedArrayToBST(nums, mid+ 1,end);
        return treeNode;
    }
```
#### 路径总和

```
   public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> lists=new ArrayList<>();
        List<Integer> list=new ArrayList<>();
        int sum1=0;
        find(root,list,lists,sum1,sum);
        return lists;
    }

    private void find(TreeNode root, List<Integer> list, List<List<Integer>> lists,int sum1,int sum) {
        if (root==null){
            return;
        }
        list.add(root.val);
        sum1=sum1+root.val;
        if (sum1==sum&&root.left==null&&root.right==null){
            lists.add(new ArrayList<>(list));
            list.remove(list.size()-1);
            sum1=sum1-root.val;
            return;
        }
        find(root.left,list,lists,sum1,sum);
        find(root.right,list,lists,sum1,sum);
        list.remove(list.size()-1);
    }
```
#### 二叉树展开为链表

```
    public void flatten(TreeNode root) {
        if (root==null){
            return;
        }
        flatten(root.left);
        flatten(root.right);
        TreeNode temp=root.right;
        root.right=root.left;
        root.left=null;
        while (root.right!=null) root=root.right;
        root.right=temp;
    }
```
#### 二叉树的右视图

```
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res=new ArrayList<>();
        helper(root,0,res);
        return res;
    }
    void helper(TreeNode root,int level,List res){
        if(root!=null) return;
        if(res.size()==level) res.add(root.val);
        helper(root.right,level+1,res);
        helper(root.left,level+1,res);
    }
```
#### 找树左下角的值

```
    int maxDepth = -1, res = -1;

    public int findBottomLeftValue2(TreeNode root) {
        helper(root, 0);
        return res;
    }

    private void helper(TreeNode root, int depth) {
        if (root == null) return;
        helper(root.left, depth + 1);
        //判断是否是最大深度
        if (depth > maxDepth) {
            maxDepth = depth;
            res = root.val;
        }
        helper(root.right, depth + 1);
    }
```
#### 二叉搜索树的最近公共祖先

```
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right, p, q);
        if (p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left, p, q);
        return root;
    }
```

####  左叶子之和

```
    public int sumOfLeftLeaves(TreeNode root) {
                if (root==null) return 0;
                return sumOfLeft(root,false);
    }
    public int sumOfLeft(TreeNode node,boolean isleft){
                if (node==null) return 0;
                if (node.left==null&&node.right==null&&isleft==true) return node.val;
                int left = sumOfLeft(node.left, true);
                int right = sumOfLeft(node.right, false);
                return left+right;
    }
```
#### 判断B是不是A的子树

```java
	public boolean hasSubTree(TreeNode root1, TreeNode root2){
		boolean result = false;
		if(root1 != null && root2 != null){
			if(root1.val == root2.val){
				result = doesTree1HaveTree2(root1, root2);
			}
			if(!result){
				result = hasSubTree(root1.left, root2);
			}
			if(!result){
				result = hasSubTree(root1.right, root2);
			}
		}
		return result;
	}
	public boolean doesTree1HaveTree2(TreeNode node1, TreeNode node2) {
		if(node2 == null){
			return true;
		}
		if(node1 == null){
			return false;
		}
		if(node1.val != node2.val){
			return false;
		}
		return doesTree1HaveTree2(node1.left, node2.left) &&
				doesTree1HaveTree2(node1.right, node2.right);
	}
```

## 排序

#### 归并排序

```
    void funMergeSort(int[] array) {
        mSort(array, 0, array.length - 1);
    }

    void mSort(int[] array, int left, int right) {
        if (left >= right) return;
        int mid = (left + right) / 2;
        mSort(array, left, mid);
        mSort(array, mid + 1, right);
        merge(array, left, mid, right);
    }

    void merge(int[] array, int left, int mid, int right) {
        int temp[] = new int[right - left + 1];
        int i = left;
        int j = mid + 1;
        int k = 0;
        while (i <= mid && j <= right) {
            if (array[i] <= array[j]) {
                temp[k++] = temp[i++];
            } else {
                temp[k++] = temp[j++];
            }
        }
        while (i <= mid) temp[k++] = temp[i++];
        while (j <= right) temp[k++] = temp[j++];
        for (int p = 0; p < temp.length; p++) {
            array[left + p] = temp[p];
        }
    }
```
#### 堆排序

```
    void funHeapSort(int[] array) {
        int n = array.length;
        for (int i = (n - 1) / 2; i >= 0; i--) {
            heapAdjust(array, i, n);
        }
        for (int i = 0; i < n; i++) {
            swap(array, 0, n - 1 - i);
            heapAdjust(array, 0, n - i - 1);
        }
    }

    private void heapAdjust(int[] array, int index, int n) {
        int tmp = array[index];
        while (index * 2 + 1 < n) {
            int child = index * 2 + 1;
            if (array[child] < array[child + 1]) child++;
            if (tmp > array[child]) {
                array[index] = tmp;
                break;
            } else {
                array[index] = array[child];
                index = child;
            }
        }
    }

    void swap(int[] array, int index1, int index2) {
        int temp = array[index1];
        array[index1] = array[index2];
        array[index2] = temp;
    }
```
#### 快速排序

```
    void funQuickSort(int[] array, int start, int end) {
        int tmp = array[start];
        int low = start;
        int high = end;
        if (low >= high) return;
        while (low < high) {
            while (array[high] > tmp && low < high) high--;
            array[low] = array[high];
            while (array[low] < tmp && low < high) low++;
            array[high] = array[low];
        }
        array[low] = tmp;
        funQuickSort(array, start, low - 1);
        funQuickSort(array, low + 1, end);
    }
```
#### 冒泡排序

```
    void funBubbleSort(int[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = 0; j < array.length - 1 - i; j++) {
                if (array[j] > array[i + 1]) {
                    int tmp = array[j];
                    array[j] = array[i + 1];
                    array[i + 1] = tmp;
                }
            }
        }
    }
```
#### 直接插入排序

```
    void funDInsertSort(int[] array) {
        for (int i = 1; i < array.length; i++) {
            int tmp = array[i];
            int j = i - 1;
            while (j > -1 && array[j] > array[i]) {
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = tmp;
        }
    }
```

## 链表

#### 合并K个排序链表

```
   public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) return null;
        return merge(lists, 0, lists.length - 1);
    }

    private ListNode merge(ListNode[] lists, int left, int right) {
        if (left == right) return lists[left];
        int mid = left + (right - left) / 2;
        ListNode l1 = merge(lists, left, mid);
        ListNode l2 = merge(lists, mid + 1, right);
        return mergeTwoLists(l1, l2);
    }

    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1,l2.next);
            return l2;
        }
    }
```
#### 两两交换链表中的节点

```
    public ListNode swapPairs(ListNode head) {
        if (head==null||head.next==null) return head;
        ListNode post=head.next.next;
        ListNode pre=head.next;
        head.next.next=head;
        head.next=swapPairs(post);
        return pre;
    }
```
#### K 个一组翻转链表

```
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode pre=null;
        ListNode post=null;
        ListNode cur=head;
        ListNode outer=head;
        for (int i=0;i<k;i++){
            if (outer==null) return head;
            outer=outer.next;
        }
        for (int i=0;i<k;i++){
            post=cur.next;
            cur.next=pre;
            pre=cur;
            cur=post;
        }
        head.next=reverseKGroup(outer,k);
        return pre;
    }
```
#### 旋转链表

```
    public ListNode rotateRight(ListNode head, int k) {
        if(head==null) return null;
        if(k==0) return head;
        ListNode p=head;
        ListNode q=head;
        int m=1;
        while (p.next!=null){
            p=p.next;
            m++;
        }
        k=k%m;
        p.next=head;
        for (int i=0;i<m-1-k;i++){
            q=q.next;
        }
        p=q.next;
        q.next=null;
        return p;
    }
```
#### 反转链表

```
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode p = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return p;
}
```
#### 反转从位置 m 到 n 的链表

```
    public ListNode reverseBetween(ListNode head, int m, int n) {
        ListNode cur=new ListNode(0);
        ListNode p=cur;
        cur.next=head;
        for (int i=0;i<m-1;i++){
            cur=cur.next;
        }
        ListNode left=cur;
        ListNode pre=null;
        cur=left.next;
        ListNode post=null;
        for (int i = 0; i < n - m + 1; i++) {
            post=cur.next;
            cur.next=pre;
            pre=cur;
            cur=post;
        }
        left.next.next=cur;
        left.next=pre;
        return p.next;
    }
```
#### 删除所有含有重复数字的节点(0)

```
    public ListNode deleteDuplicates(ListNode head) {
        if (head==null) return null;
        if (head.next!=null&&head.next.val==head.val){
            while (head.next!=null&&head.next.val==head.val){
                head=head.next;
            }
            return deleteDuplicates(head.next);
        }else {
            head.next=deleteDuplicates(head.next);
            return head;
        }
    }
```
#### 删除所有重复的元素(1)

```
    public ListNode deleteDuplicates1(ListNode head) {
        ListNode p = head;
        while (p != null) {
            if (p.next != null && p.val == p.next.val) {
                p.next = p.next.next;
            } else {
                p = p.next;
            }
        }
        return head;
    }
```

#### 两个链表的第一个公共结点

```
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        ListNode l1 = pHead1, l2 = pHead2;
        while (l1 != l2) {
            l1 = (l1 == null) ? pHead2 : l1.next;
            l2 = (l2 == null) ? pHead1 : l2.next;
        }
        return l1;
    }
```

#### 链表入环的第一个节点

```
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while (true) {
            if (fast == null || fast.next == null) return null;
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
        }
        fast = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return fast;
    }
```
#### 重排链表

```
    public void reorderList(ListNode head) {
        LinkedList<ListNode> nodeQueue=new LinkedList();
        ListNode p=head;
        while (p!=null){
            nodeQueue.addLast(p);
            p=p.next;
        }
        p=head;
        while (!nodeQueue.isEmpty()){
            p.next=nodeQueue.pollFirst();
            p=p.next;
            p.next=nodeQueue.pollLast();
            p=p.next;
        }
        if (p!=null){
            p.next=null;
        }
    }
```
#### 对链表进行冒泡排序

```
	public static ListNode bubbleSort(ListNode head){
        if(head == null || head.next == null)
            return head;
        ListNode cur = null, tail = null;
        cur = head;
        while(cur.next != tail){
            while(cur.next != tail){
                if(cur.val > cur.next.val){
                    int tmp = cur.val;
                    cur.val = cur.next.val;
                    cur.next.val = tmp;
                }
                cur = cur.next;
            }
            tail = cur;  //下一次遍历的尾结点是当前结点(仔细琢磨一下里面的道道)
            cur = head;     //遍历起始结点重置为头结点    
        }
        return head;
    }
```
#### 对链表进行插入排序

```
    public ListNode insertionSortList(ListNode head) {
        ListNode dummy=new ListNode(0);
        ListNode pre=dummy;
        ListNode cur=head;
        while (cur!=null){
            ListNode tmp=cur.next;
            while (pre.next!=null&&pre.next.val<cur.val){
                pre=pre.next;
            }
            cur.next=pre.next;
            pre.next=cur;
            pre=dummy;
            cur=tmp;
        }
        return dummy.next;
    }
```
#### 链表快速排序

```
    public ListNode sortList(ListNode head) {
        quickSort(head, null);
        return head;
    }
    
    void quickSort(ListNode head, ListNode tail){
        if(head == tail || head.next == tail) return;
        int pivot = head.val;
        ListNode left = head, cur = head.next;
        
        while(cur != tail){
            if(cur.val < pivot){
                left = left.next;
                swap(left, cur);
            }
            cur = cur.next;
        }
        swap(head, left);
        quickSort(head, left);
        quickSort(left.next, tail);
    }
```

#### KMP

```
void SetPrefix(const char *Pattern, int prefix[]){
     int len=CharLen(Pattern);
     prefix[0]=0;
     for(int i=1; i<len; i++){
         int k=prefix[i-1];
         while( Pattern[i] != Pattern[k]  &&  k!=0 ) 
             k=prefix[k-1]; 
         if( Pattern[i] == Pattern[k])
              prefix[i]=k+1;
         else
              prefix[i]=0;
     }
}
    public static int getIndexOf(String str1, String str2){
        if(str1 == null || str2 == null || str2.length() < 1 || str1.length() < str2.length()){
            return -1;
        }
        int p1 = 0;  // str1的指针
        int p2 = 0;  // str2的指针
        char[] s1 = str1.toCharArray();
        char[] s2 = str2.toCharArray();
        int[] next = getNextArray(s2);
        while(p1 < str1.length() && p2 < str2.length()){
            if(s1[p1] == s2[p2]){
                p1++;
                p2++;
            }else{
                if(next[p2] == -1){
                    p1++;
                }else{
                    p2 = next[p2];
                }
            }
        }
        return p2 == s2.length ? p1 - p2 : -1;
    }
```

![1568960867025](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1568960867025.png)

## 图

```
public class Graph {
    // ----------------------------图的表示方式------------------------
    private int vertexSize;// 顶点的数量
    private int[][] matrix;// 邻接矩阵
    private boolean[] isVisited; // 顶点是否已经被访问

    public Graph(int vertexSize) {
        this.vertexSize = vertexSize;
        this.matrix = new int[vertexSize][vertexSize];
        isVisited = new boolean[vertexSize];
    }
    public int getFirstNeighbor(int index) {
        for (int i = 0; i < vertexSize; i++) {
            if (matrix[index][i] > 0 && matrix[index][i] != 1000) {
                return i;
            }
        }
        return -1;
    }

    public int getNextNeighbor(int v, int index) {
        for (int i = index + 1; i < vertexSize; i++) {
            if (matrix[v][i] > 0 && matrix[v][i] != 1000) {
                return i;
            }
        }
        return -1;
    }
    // ----------------------------两个重要方法------------------------
    // 对外提供的深度优先遍历
    public void depthFirstSearch() {
        for (int i = 0; i < vertexSize; i++)
            if (!isVisited[i]) {
                depthFirstSearch(i);
            }
    }
    // 图的深度优先遍历算法 ---- 从顶点i进行遍历
    private void depthFirstSearch(int i) {
        isVisited[i] = true;
        int FN = getFirstNeighbor(i);
        while (FN != -1) {
            if (!isVisited[FN]) {
                System.out.println("遍历到了" + FN + "顶点"); // 遍历该顶点
                depthFirstSearch(FN);
            }
            FN = getNextNeighbor(i, FN);
        }
    }

    // 对外提供的广度优先遍历
    public void broadFirstSearch() {
        for (int i = 0; i < vertexSize; i++)
            if (!isVisited[i]) {
                broadFirstSearch(i);
            }
    }

    private void broadFirstSearch(int i) {
        Queue<Integer> queue = new LinkedList<>();
        queue.add(i);
        isVisited[i] = true; // 标记该顶点已经被遍历过
        System.out.println("遍历到了" + i + "顶点");
        while (!queue.isEmpty()) {
            // 弹出队首的元素
            Integer head = queue.poll();
            // 获取队首元素第一个邻接点的元素
            int FN = getFirstNeighbor(head);
            while (FN != -1) { // 如果有第一个邻接点
                if (!isVisited[FN]) {// 且该邻接点没有被访问过
                    isVisited[FN] = true;// 标记该顶点已经被遍历过
                    System.out.println("遍历到了" + FN + "顶点");
                    queue.add(FN); // 让FN进人队列
                }
                // 遍历队列首元素head基于FN的下一个元素
                FN = getNextNeighbor(head, FN);
            }
        }

    }

}
```