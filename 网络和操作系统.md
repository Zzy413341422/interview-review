# 计算机网络

## HTTP协议是什么

HTTP协议是超文本传输协议,是用于从万维网服务器传输超文本到本地浏览器的传送协议，是一种规范。

## HTTP是一个基于TCP/IP通信协议来传递数据

![HTTP Request è¯·æ±æ¥ææ ¼å¼](https://img-blog.csdn.net/20170330192653242?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## HTTPS和HTTP的区别

Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：
端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；
资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；
开销：Https通信需要证书，而证书一般需要向认证机构购买； 

## SSL原理

![img](https://upload-images.jianshu.io/upload_images/8115459-3e0ec0b17cc9d8f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/567/format/webp)

## HTTP1.0和HTTP1.1和HTTP2.0区别

HTTP1.0：expire

HTTP1.1：Connection:keep-alive、cache-control

HTTP2.0：     1.头部压缩，只用二进制替换文本；

![img](https://upload-images.jianshu.io/upload_images/5281821-5e2e23de6cbbc698.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/607/format/webp)

​			2.HTTP/2是完全多路复用的
​			3.服务器推送：还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。

## Http缓存

强制缓存：

对比缓存：

**Cache-Control**
Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。
private:             客户端可以缓存
public:              客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）
max-age=xxx:   缓存的内容将在 xxx 秒后失效
no-cache:          需要使用对比缓存来验证缓存数据（后面介绍）

## HTTP请求的GET方法和POST方法的区别？

GET与POST是我们常用的两种HTTP Method，二者之间的区别:
(1). 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；
(2). 从请求参数形式上看，GET请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&相连。
(3). 就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。
(4). 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。

## 转发和重定向的区别：

1、浏览器URL的地址栏不变。重定向：浏览器URL的地址栏改变；
2、转发是服务器行为，重定向是客户端行为；
3、转发是浏览器只做了一次访问请求。重定向是浏览器做了至少两次的访问请求的；
4、转发2次跳转之间传输的信息不会丢失，重定向2次跳转之间传输的信息会丢失（request范围）。

## HTTP无状态？session和cookie怎么实现的，怎么去更新session？

HTTP无状态协议，是指协议对事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传。
Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。

## session和cookie的区别，禁用cookie后怎么办

实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；
大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；
安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；
若浏览器禁用Cookie的话，可以通过 URL重写机制将sessionid传回服务器。

## 常见状态码及原因短语

200：服务器已成功处理了请求。 204:表示服务器接收到的请求已经处理完毕，但是服务器不需要返回响应体.
300：提供操作列表供请求者选择 301 : 永久性转移 302 ：暂时性转移 304 ：页面已缓存
400：语法错误  401：表示发送的请求需要有通过 HTTP 认证的认证信息 403：拒绝请求  404：客户端所访问的页面不存在 
500 ：服务器内部错误       502：错误网关    503 ： 服务不可用，稍等

## TCP\UDP的区别

TCP是面向连接的，UDP是无连接的；
TCP是可靠的，UDP是不可靠的；
TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；
TCP是面向字节流的，UDP是面向报文的；

## 对于可靠性，TCP通过以下方式进行保证：

##### 数据包校验：

目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；

##### 对失序数据包重排序：

既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；

##### 丢弃重复数据：

对于重复数据，能够丢弃重复数据；

##### 应答机制：

当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；

##### 超时重发：

当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；

##### 流量控制：

TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。 

![img](https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg)

## UDP实现TCP可靠传输

1. 添加seq/ack机制，确保数据发送到对端
2. 添加发送和接收缓冲区，主要是流量控制
3. 添加超时重传机制

## ARQ停止等待协议

发送方每发送一帧就暂停，等待应答（ACK）到来。收方收到数据帧后发送应答（ACK）帧给发送方，发送方再发送下一个数据帧。

## 连续ARQ协议

连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。
缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。

## 地址解析协议 ARP

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20170820105759407?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzMwOTg3MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

功能：在发送数据时，数据从高层到低层，然后才到通信链路上传输。使用IP地址的IP数据报一旦交给了数据链路层，就被封装成了MAC帧。MAC帧在传送时使用的源地址和目的地址都是硬件地址。连接在通信链路上的设备（主机或路由器）在接收MAC帧时，根据是MAC帧首部的硬件地址。在数据链路层看不到隐藏在MAC帧中的IP地址。只有在剥去MAC帧的首部和尾部后把MAC层的数据交给网络层后，网络层才能在IP数据报的首部中找到源IP地址和目的IP地址。 

工作流程：如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。

## 拥塞控制

TCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。

送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。

快重传：没收到确认，连续发送3个回去；快恢复：拥塞窗口大小减半

## OSI参考模型的分为哪几层，每层的功能？

OSI，开放系统互连参考模型，它的7个层次自顶到下依次为应用层，表示层，会话层，传输层，网络层，数据链路层和物理层。

![äºå±åè®®çä½ç³»ç»æ](https://camo.githubusercontent.com/94ac65420edf518aa8059bae10125db1d0a35c81/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f372f32392f313634653533303734373165386562613f773d36333326683d33343426663d706e6726733d313634363233)

## 如何解决拆包粘包？

使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。
设置定长消息，服务端每次读取既定长度的内容作为一条完整消息。
设置消息边界，服务端从网络流中按消息编辑分离出消息内容。

## 在浏览器中输入网址到显示出页面的整个过程？

(1) 输出包含域名的网址 (2) 浏览器向DNS请求解析域名对应的IP地址 (3) 域名系统DNS解析出域名对应的IP地址 (4) 浏览器与该服务器建立TCP连接 (5) 浏览器发送HTTP请求 (6) 服务器通过HTTP响应把页面文件发送给浏览器 (7) TCP连接释放 (8) 浏览器解释文件，并显示

## DNS 解析

![img](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1561272642008&di=6c7eee691b0a2876dd7cb10c83a60354&imgtype=0&src=http%3A%2F%2Fseo-1255598498.file.myqcloud.com%2Ffull%2F069b59a615bb8a8b35a09cebce0f2798e659af81.jpg)

## http协议与tcp/ip协议有什么区别？http三次握手画图说明。

​	IP想象成一种高速公路，它允许其它协议在上面行驶并找到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等

![TCPä¸æ¬¡æ¡æ](https://camo.githubusercontent.com/e399530014904f78b9a709a7a8accbbb85755b18/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f382f313633336531343233336439353937323f773d35343226683d34323726663d6a70656726733d3135303838)

![TCPåæ¬¡æ¥æ](https://camo.githubusercontent.com/ae140718e064bf5f444224c9da3cdc2b8cd9f9a6/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f352f382f313633336531363736653261633061333f773d35303026683d33343026663d6a70656726733d3133343036)

## 为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：最主要的原因就是双方3次握手可以确认自己与对方的发送与接收是正常的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

## 你刚刚说了4次挥手，time_wait和close_wait有什么区别？

Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
TIME_WAIT 是主动关闭链接时形成的, 主要是防止最后一个ACK丢失

## IP地址分类，子网划分（笔试常用）

https://blog.csdn.net/binggetong/article/details/52729175

## 网线断了TCP连接情况

处于半连接状态；客户端多次收不到服务器的响应时可终止此TCP连接，而服务端可监测客户端的心跳包，若在一定时间间隔内未收到任何来自客户端的心跳包则可以终止此TCP连接。

## DDOS攻击

原因：客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

预防：限制同时打开SYN半链接的数目；缩短SYN半链接的Time out 时间

## SQL注入

原因：SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

预防：对sql语句预编译，使用正则表达式过滤传入的参数

## XSS攻击

原因：恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到web页面中去

预防：正则表达式过滤；

## CSRF攻击

CSRF攻击是攻击者利用用户的身份操作用户帐户的一种攻击方式

预防：后端尽量使用post接口、加验证码；

# 操作系统

## 操作系统的四个特性

并发，共享，虚拟，异步

## 上下文切换

上下文切换(Context Switch)是一种将CPU资源从一个线程分配给另一个线程的机制。

## 守护、僵尸、孤儿进程的概念

守护进程：守护进程就是运行在后台，不与任何终端关联的进程。通常情况下守护进程在系统启动时就在运行。
僵尸进程：僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。
孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，这些子进程称为孤儿进程。

## 请分别简单说一说进程和线程以及它们的区别。

进程是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发；
线程是进程的子任务，是CPU调度和分配的基本单位，实现进程内部的并发；
一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；
进程拥有独立的内存单元，而多个线程共享进程的内存。

## 线程同步的方式有哪些？

互斥 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

## 进程同步

1. 临界区
2. 同步与互斥
3. 信号量
4. 管程（类似Synchronized）

## 进程间的通信的几种方式

管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；

信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；

消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；

共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；

信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；

套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

## 线程有几种状态？进程有哪几种状态？

就绪状态，运行状态，阻塞状态
创建、就绪、运行、阻塞、等待、时间等待和消亡。

## 进程调度算法

### 批处理系统（人数比较少）

先来先服务：有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行

短作业优先 ：如果一直有短作业到来，那么长作业永远得不到调度。

最短剩余时间优先 ：任务剩余时间越短，则不管长短作业，先执行。

### 交互式系统（人数比较多）

时间片轮转：进程可以执行一个时间片，当时间片用完时，将它送往就绪队列的末尾。

优先级调度：为每个进程分配一个优先级，按优先级进行调度。

多级反馈队列：多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。

## 操作系统的虚拟内存

在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。虚拟内存就是在硬盘上面划分出一个区域来充当内存,和物理内存共同来处理信息。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。

## 操作系统的用户态和核心态切换条件以及为什么要切换

当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。

## 分段和分页有什么区别（内存管理）？

打个比方，比如说你去听课，带了一个纸质笔记本做笔记。笔记本有100张纸，课程有语文、数学、英语三门，对于这个笔记本的使用，为了便于以后复习方便，你可以有两种选择。


第一种是，你从本子的第一张纸开始用，并且事先在本子上做划分：第2张到第30张纸记语文笔记，第31到60张纸记数学笔记，第61到100张纸记英语笔记，最后在第一张纸做个列表，记录着三门笔记各自的范围。这就是分段管理，第一张纸叫段表。


第二种是，你从第二张纸开始做笔记，各种课的笔记是连在一起的：第2张纸是数学，第3张是语文，第4张英语……最后呢，你在第一张纸做了一个目录，记录着语文笔记在第3、7、14、15张纸……，数学笔记在第2、6、8、9、11……，英语笔记在第4、5、12……。这就是分页管理，第一张纸叫页表。你要复习哪一门课，就到页表里查寻相关的纸的编号，然后翻到那一页去复习

两者的不同点：
段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制；页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制
页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定

## 操作系统页置换的算法

FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；
LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；
LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；
OPT（Optimal replacement）最优置换算法：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法。

## 死锁的概念:

两个或多个线程无限期的阻塞、相互等待的一种状态。

” Jconsole查看死锁“

死锁原因： 
竞争资源：请求同一有限资源的进程数多于可用资源数
进程推进顺序非法：进程执行中，请求和释放资源顺序不合理，如资源等待链

## 死锁产生的必要条件：

互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；
占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；
非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放
循环等待：若干进程之间形成一种头尾相接的环形等待资源关系

## 死锁处理：

预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；
避免死锁：在资源的动态分配中，防止系统进入可能产生死锁的状态-如银行家算法
检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程
解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。

## 经典的线程同步问题（哲学家，生产消费）

生产者消费者问题
哲学家进餐问题
银行家算法`