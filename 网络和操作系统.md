# 计算机网络

## OSI参考模型的分为哪几层，每层的功能？

![äºå±ä½ç³»ç»æ](C:/Users/admin/Desktop/interview-review/md/68.png)

#### 物理层（比特流）

物理层负责用光纤把两台计算机连起来，然后在计算机之间通过高低电频来传送0,1这样的电信号。

#### 数据链路层（帧）

规定0,1电信号协议。

#### 网络层（数据包）

封装ip数据头-》封装mac数据头（ARP）

#### 传输层（段）

tcp数据头

#### 应用层（报文）

HTTP、DNS

## 在浏览器中输入网址到显示出页面的整个过程？

第一次握手：输入网址-》dns解析（dns解析）-》封装tcp数据头-》封装ip数据头-》封装mac数据头（ARP）-》通过数据链路层将数据发送到目标地址端口。

完成三次握手：后面两次无需dns解析和ARP。

浏览器发送HTTP请求-》得到HTTP响应体-》默认2小时11分后释放TCP连接。

## HTTP协议是什么

HTTP协议是超文本传输协议,是用于从万维网服务器传输超文本到本地浏览器的传送协议，是一种规范。

## HTTP

![âhttpæ¥ææ ¼å¼âçå¾çæç´¢ç»æ](md\62.jpg)

## HTTPS和HTTP的区别

HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。

HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。

HTTP 的端口号是 80，HTTPS 的端口号是 443。

HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

## SSL原理

### SSL/TLS 协议基本流程

客户端向服务器索要并验证服务器的公钥。

双方协商生产「会话秘钥」。

双方采用「会话秘钥」进行加密通信。

### 对称加密和非对称加密

对称加密：信息的发送方和接收方用一个密钥去加密和解密数据，加/解密速度快。

非对称加密：加密和解密速度却比对称密钥加密慢得多。

1客户端随机数＋3服务器随机 + 4pre-master = 对称秘钥

![img](md\63.jpg)

## CA证书

![img](md\108.png)

## 中间人攻击

![img](md\64.png)

## HTTP1.1和HTTP2.0区别

### HTTP1.1

#### 优点

1、长连接

2、管道（只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去）

#### 缺点

请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；

发送冗长的首部。每次互相发送相同的首部造成的浪费较多；

然而pipelining在接收response返回时，也必须依顺序接收，如果前一个请求遇到了阻塞，后面的请求即使已经处理完毕了，仍然需要等待阻塞的请求处理完毕。

### HTTP2.0

#### 优点

头部压缩

二进制格式：因为计算机只懂二进制，可以直接解析二进制报文

多路复用：一个连接中并发多个请求

服务器推送：还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。

#### 缺点

HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。

### HTTP3.0

HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP

大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。

QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。

TL3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack。

HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。

## Http缓存

强制缓存：收到请求，看是否有缓存，直接使用缓存。

对比缓存：收到请求，看是否有缓存，然后向服务器询问缓存是否可用，可用则返回304；如果不匹配，表示资源有更新，服务器会将新数据和新的缓存标识一起返回到浏览器

**Cache-Control**
Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。
private:             客户端可以缓存
public:              客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）
max-age=xxx:   缓存的内容将在 xxx 秒后失效
no-cache:          需要使用对比缓存来验证缓存数据（后面介绍）

## HTTP请求的GET方法和POST方法的区别？

GET与POST是我们常用的两种HTTP Method，二者之间的区别:
从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；
从请求参数形式上看，GET请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&相连。
从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。

## 转发和重定向的区别：

1、浏览器URL的地址栏不变。重定向：浏览器URL的地址栏改变；
2、转发是服务器行为，重定向是客户端行为；
3、转发是浏览器只做了一次访问请求。重定向是浏览器做了至少两次的访问请求的；
4、转发2次跳转之间传输的信息不会丢失，重定向2次跳转之间传输的信息会丢失（request范围）。

## HTTP无状态？session和cookie怎么实现的

HTTP无状态协议，是指协议对事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传。
Cookie和Session都是客户端与服务器之间保持状态的解决方案，cookie是在http请求头的cookie字段中，而session保存在服务端。

## session和cookie的区别

1、session 在服务器端，cookie 在客户端
2、Session的实现常常依赖于Cookie机制，若浏览器禁用Cookie的话，可以通过 URL重写机制将sessionid传回服务器。
3、Cookie有大小限制，Session没有大小限制。
4、Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session用于保存在服务器端，相对更加安全；

## 常见状态码及原因短语

1xx

1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。

2xx

2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。

「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。

「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。

「206 Partial Content」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

3xx

3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。

「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。

「302 Moved Permanently」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。

301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。

4xx

4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。

「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。

「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。

「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。

5xx

5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。

「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。

「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。

「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。

「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。

## DNS 解析

浏览器缓存、本地缓存-》

![](C:/Users/admin/Desktop/interview-review/md/101.png)

CDN网络是在用户和服务器之间增加Cache层（较近网络服务器），主要是通过接管DNS实现，将用户的请求引导到Cache上获得源服务器的数据，从而降低网络的访问的速度。

## DNS劫持

## TCP的含义

TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。

![img](md\66.png)

## TCP\UDP的区别

1. 连接

TCP 是面向连接的传输层协议，传输数据前先要建立连接。

UDP 是不需要连接，即刻传输数据。

2. 服务对象

TCP 是一对一的两点服务，即一条连接只有两个端点。

UDP 支持一对一、一对多、多对多的交互通信

3. 可靠性

TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。

UDP 是尽最大努力交付，不保证可靠交付数据。

4. 拥塞控制、流量控制

TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。

UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

5. 首部开销

TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。

UDP 首部只有 8 个字节，并且是固定不变的，开销较小。

## TCP 和 UDP 应用场景

由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

FTP 文件传输

HTTP / HTTPS

由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：

包总量较少的通信，如 DNS 、SNMP 等

视频、音频等多媒体通信

广播通信

## 对于可靠性，TCP通过以下方式进行保证：

### 重传机制

TCP拥有两套独立机制来完成重传。一是基于时间，二是基于确认消息（SACK）

#### 超时重发

当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；

#### 快速重传

快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。

#### SACK

这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。

![img](md\112.png)

发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。

### 滑动窗口

口大小就是指无需等待确认应答，而可以继续发送数据的最大值。

滑动窗口并不是一成不变的。新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。
![img](md\67.jpg)

### 流量控制

发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会被操作系统调整。采用先收缩窗口，过段时间在减少缓存。

### 拥塞控制

TCP的拥塞控制采用了四种算法，即 慢开始 、拥塞避免 、拥塞发生、快速恢复

#### 慢开始

当发送方每收到一个 ACK，就拥塞窗口 cwnd 的大小就会加 1。

#### 拥塞避免

当慢启动涨到慢启动门限，就会触发拥塞避免，每当收到一个 ACK 时，cwnd 增加 1/cwnd。

![](md\113.png)

#### 拥塞发生

当触发了重传机制，也就进入了「拥塞发生算法」。

超时重传：ssthresh 设为 cwnd/2，cwnd 重置为 1。

快速重传：cwnd = cwnd/2 ，也就是设置为原来的一半。ssthresh = cwnd;

#### 快速恢复

快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕

![](md\114.png)

拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）

重传丢失的数据包

如果再收到重复的 ACK，那么 cwnd 增加 1

如果收到新数据的 ACK 后，设置 cwnd 为 ssthresh，接着就进入了拥塞避免算法

## tcp/ip和http协议区别

IP想象成一种高速公路，它允许其它协议在上面行驶并找到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等

## TCP三次握手

![ä¸æ¬¡æ¡æ](C:/Users/admin/Desktop/interview-review/md/72.png)

## 为什么是三次握手？

三次握手才可以阻止历史重复连接的初始化（主要原因）（客户端通过上下文比较seq）

三次握手才可以同步双方的初始序列号（保证可靠传输）

三次握手才可以避免资源浪费

## 不使用「两次握手」和「四次握手」的原因

「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；

「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

## 初始序列号 ISN 是如何随机产生的？

ISN = M + F (localhost, localport, remotehost, remoteport)

M 是一个计时器，这个计时器每隔 4 毫秒加 1。

F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。

## SYN攻击

![ä¸æ¬¡æ¡æ](C:/Users/admin/Desktop/interview-review/md/109.png)

### 正常流程

当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；

接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；

服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；

应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。

### tcp_syncookies 的方式可以应对 SYN 攻击的方法

当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；

计算出一个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端，

服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。

最后应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。

## TCP四次挥手

![åæ¬¡æ¥æ](C:/Users/admin/Desktop/interview-review/md/73.png)

## 为什么挥手需要四次？

服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。

## TIME_WAIT 和CLOSE_WAIT区别

Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
TIME_WAIT 是主动关闭链接时形成的, 主要是防止最后一个ACK丢失和影响到新的TCP连接。

## 为什么 TIME_WAIT 等待的时间是 2MSL

### 防止旧连接的数据包

有相同端口的 TCP 连接被复用后，被延迟的TCP报文抵达了客户端，那么客户端是有可能正常接收这个过期的报文，经过 2MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。

### 保证连接正确关闭

防止最后一个ACK报文丢失

## TIME_WAIT 过多有什么危害

第一是服务端内存资源占用；

第二是对客户端端口资源的占用，一个 TCP 连接至少消耗一个本地端口；

## 如何优化 TIME_WAIT

### 打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；

前提：如下的 Linux 内核参数开启后，则可以复用处于 TIME_WAIT 的 socket 为新的连接所用。有一个前提，需要打开对 TCP 时间戳的支持net.ipv4.tcp_timestamps 。

缺点：当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉。

### net.ipv4.tcp_max_tw_buckets

这个值默认为 18000，当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置。

缺点：这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。

### 程序中使用 SO_LINGER ，应用强制使用 RST 关闭。

我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。调用close后，会立该发送一个RST标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了TIME_WAIT状态，直接关闭。

缺点：非常危险。

### 将连接方式由短连接或者长连接

所以并发量大，但每个用户无需频繁操作情况下需用短连好。 但每个用户需频繁操作，用长连接

## 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP 有一个机制是保活机制。

net.ipv4.tcp_keepalive_time=7200
net.ipv4.tcp_keepalive_intvl=75  
net.ipv4.tcp_keepalive_probes=9

也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。

## 地址解析协议 ARP

**ARP用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址**。

工作流程：通信时必须要有mac地址，在syn报文到达网络层时，进行一次ARP请求和回复过程，然后封装mac到报文中，且缓存起来。

#### 能不能去掉MAC地址呢？

1.主要原因是ip地址是变化的，没有mac地址容易被盗用身份

2.IPV4地址有限，只有40亿个，因此需要NAT技术。NAT技术是使用内网IP的，内网IP是根据MAC地址分配的，路由器会保存一个MAC地址映射表。

## TCP粘包

现象：一个socket端口接受到send(500)+send(1000)，但receive时候可能出现800+700，需要应用层出处理流不对的问题。因为tcp只保证可靠，不保证字节流不合并。

## ping指令的整个过程

ping通知系统建立一个固定格式的ICMP请求数据包，根据ip地址获取对方mac地址，若本机无缓存，则进行一次ARP请求和回复过程，然后封装mac到报文中，机器B收到这个数据帧后，先检查目的地址，和本机MAC地址对比符合，接收。

## DDOS攻击

原因：客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

预防：限制同时打开SYN半链接的数目；缩短SYN半链接的Time out 时间

## SQL注入

原因：SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

预防：对sql语句预编译，使用正则表达式过滤传入的参数

## XSS攻击

原因：用 <script type="text/javascript"></script> 包起来发送的回帖中

预防：正则表达式过滤，将script关键字获取到；

## CSRF攻击

通过xss创建一个自动提交的表格，冒充用户进行一些操作。

预防：请求头加token字段

## Socket网络编程

![åæ¬¡æ¥æ](md\110.png)

## Socket网络编程和三次握手

![åæ¬¡æ¥æ](md\111.png)





# 操作系统

是一种系统软件，负责管理协调计算机硬件和软件资源以及为用户和程序提供服务

## 操作系统的四个特性

并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。

共享：互斥共享方式，同时共享方式

虚拟：虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。

异步：多个进程走走停停，以不可预知的速度向前推进，这就是进程的异步性。

同步：各个进程遵循一定的先后顺序

## 并发和并行

并发:指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。

常考易混概念- --并行:指两个或多个事件在同一时刻同时发生。

## 上下文切换

上下文切换(Context Switch)是一种将CPU资源从一个线程分配给另一个线程的机制。

## 大内核、微内核

![1574478626805](md\74.png)

内核就是企业的管理层，负责-一些重要的工作。只有管理层才能执行特权指令，普通员工只能
执行非特权指令。用户态、核心态之间的切换相当于普通员工和管理层之间的工作交接
大内核:企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高;缺点是组织
结构混乱，难以维护。
微内核:随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方
便维护;缺点是效率低。

## 守护、僵尸、孤儿进程的概念

守护进程：守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。
僵尸进程：僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。
孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，这些子进程称为孤儿进程。

## 请分别简单说一说进程和线程以及它们的区别。

​    1.进程要分配一大部分的内存，而线程只需要分配一部分栈就可以了.
​    2.一个程序至少有一个进程,一个进程至少有一个线程.
​    3.进程是资源分配的最小单位，线程是程序执行的最小单位。
​    4.一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行.
​    5.进程与进程之间的交互通过TCP/IP的端口来实现，线程的通信就比较简单，有一大块共享的内存，只要大家的指针是同一个就可以看到各自的内存。
​    操作系统真正运行的是一个个的线程，而进程可以看做是线程的一个容器。

## 线程同步的方式有哪些？

互斥 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
信号量 semaphore：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
事件(信号)Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

## 进程同步

1. 临界区
3. 信号量
4. 管程（类似Synchronized）：每次仅允许一个进程在管程内执行

## 进程间的通信的几种方式

管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；

信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；

消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；

共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；

信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；

套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

## 线程有几种状态？进程有哪几种状态？

就绪状态，运行状态，阻塞状态
创建、就绪、运行、阻塞、等待、时间等待和消亡。

## 进程调度和进程切换

狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，
也可能是另一个进程，后一种情况就需要进程切换）
进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。

## 进程调度算法

### 批处理操作系统

先来先服务：有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行

短作业优先 ：如果一直有短作业到来，那么长作业永远得不到调度。

最短剩余时间优先 ：任务剩余时间越短，则不管长短作业，先执行。

### 交互式操作系统

时间片轮转：进程可以执行一个时间片，当时间片用完时，将它送往就绪队列的末尾。

优先级调度：为每个进程分配一个优先级，按优先级进行调度。

多级反馈队列：多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。

## 中断、系统调用、库函数

#### 中断

外部中断一般是指由计算机外设发出的中断请求
内部中断是指因硬件出错
软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序。
一、当中断发生时，CPU立即进入核心态.
二、当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理
三、对于不同的中断信号，会进行不同的处理

#### 系统调用

系统调用是通向操作系统本身的接口，是面向底层硬件的。通过系统调用，可以使得
用户态运行的进程与硬件设备(如：CPU、磁盘、打印机等)进行交互。
用户进程需要发生系统调用时，内核将调用内核相关函数来实现（如：sys_read()、
sys_write()、sys_fork()）。用户程序不能直接调用这些函数，这些函数运行在内核态，
CPU 通过软中断切换到内核态开始执行内核系统调用函数。
系统调用和中断的关系就在于，当进程发出系统调用申请的时候，会产生一个软中
断。产生这个软中断以后，系统会去对这个软中断进行处理，这个时候进程就处于核心态
了。

#### 库函数

库函数是把函数放到库里，供别人使用的一种方式。【系统调用是为了方便使用操作
系统的接口，而库函数则是为了人们编程的方便。】

## 用户态、核心态之间的切换

“用户态>核心态” 是通过中断实现的。并且中断是唯一途径。
“核心态<用户态”的切换是通过执行一个特权指令，将程序状态字(PSW) 的标志位设置为“用户态”

## 操作系统的用户态和核心态切换条件以及为什么要切换

当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。

## 内存分配分为连续分配和非连续分配管理两种

#### 内存连续分配

1、单一连续分配：分为系统区和用户区，系统区供给操作系统使用，用户区供给用户使
用，内存中永远只有一道程序。
2、固定分区分配：最简单的一种多道程序管理方式，它将用户内存空间划分为若干个固定
大小的区域，每个分区只装入一道作业。【方法一：分区大小相等；方法二：分区大小不
等，划分为含有多个较小的分区，适量的中等分区及少量的大分区】
3、动态分区分配：又称为可变分区分配，是一种动态划分内存的方法。这种分区方法不预
先将内存划分，而是在进程装入内存时，根据进程的大小动态的建立分区，并使分区的大
小正好适合进程的需要。因此系统中分区的大小和数目是可变的。

#### 非连续分配

分页就是将这些段，例如代码段分成均匀的小块，然后这些给这些小块编号，然后就可以放到内存中去，由于编号了的，所以也不怕顺序乱

分段就是将一个程序分成代码段，数据段，堆栈段什么的

## 分段和分页有什么区别（内存管理）？

分页对用户不可见，分段对用户可见。

分页的地址空间是一维的（地址），分段的地址空间是二维的（段名和地址）。

页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制

页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定。

## 操作系统的虚拟内存

在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。虚拟内存就是在硬盘上面划分出一个区域来充当内存,和物理内存共同来处理信息。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。

## 操作系统页置换的算法

FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；
LRU算法：根据使用时间到现在的长短来判断；
OPT算法：丢弃最晚使用的数据
CLOCK算法：循环队列，如果访问为为0，则访问位+1或置换；如果为1，则跳过；如果都为1，全部变为0。

## 磁盘调度算法

先来先服务：按照磁盘请求的顺序进行调度。

最短寻道时间优先：优先调度与当前磁头所在磁道距离最近的磁道。

电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

## 硬链接和软链接

文件共享的两种方式：软链接相当于快捷方式（link文件指向程序），硬链接不同用户的文件表有指向同一程序的指针。

![img](md\75.jpg)

## 死锁的概念:

两个或多个线程无限期的阻塞、相互等待的一种状态。

” Jconsole查看死锁“

死锁原因： 
竞争资源：请求同一有限资源的进程数多于可用资源数
进程推进顺序非法：进程执行中，请求和释放资源顺序不合理，如资源等待链

## 死锁产生的必要条件：

互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；
占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；
非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放
循环等待：若干进程之间形成一种头尾相接的环形等待资源关系

## 死锁处理策略：

预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；
避免死锁：在资源的动态分配中，防止系统进入可能产生死锁的状态-如银行家算法
检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程
解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。

## 经典的线程同步问题（哲学家，生产消费）

生产者消费者问题
哲学家进餐问题
银行家算法

```
Allocation　　　Max　　　Available
 　　 ＡＢＣＤ　　  ＡＢＣＤ　　ＡＢＣＤ
 P1   ００１４　　  ０６５６　　１５２０　
 P2　 １４３２　　  １９４２　
 P3　 １３５４　  　１３５６
 P4 　１０００　　  １７５０
```