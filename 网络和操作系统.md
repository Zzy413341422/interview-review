# 计算机网络

## HTTP协议是什么

HTTP协议是超文本传输协议,是用于从万维网服务器传输超文本到本地浏览器的传送协议，是一种规范。

## HTTP是一个基于TCP/IP通信协议来传递数据

![âhttpæ¥ææ ¼å¼âçå¾çæç´¢ç»æ](md\62.jpg)

## HTTPS和HTTP的区别

Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：
端口不同：Http与Https使用不同的连接方式，用的端口也不一样，前者是80，后者是443；
资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；
开销：Https通信需要证书，而证书一般需要向认证机构购买； 

## SSL原理

对称加密：信息的发送方和接收方用一个密钥去加密和解密数据，加/解密速度快。

非对称加密：加密和解密速度却比对称密钥加密慢得多。

![img](md\63.jpg)

证书其实就是公钥 + 签名，由第三方认证机构颁发。我们安装的正规浏览器中都预存了正规认证机构的证书（包含其公钥），用于确认机构身份，所以说证书的认证是可信的。

数字签名的作用本来就不是保证数据的机密性，而是证明你的身份。将收到的数据和签名经过解密后的结果作对比，如果完全相同，说明数据没被篡改

![img](md\64.png)

## HTTP1.0和HTTP1.1和HTTP2.0区别

HTTP1.0：expire

HTTP1.1：Connection:keep-alive、cache-control

HTTP2.0：     1.头部压缩，用二进制替换文本；

![img](md\65.jpg)

​			2.HTTP/2是完全多路复用的
​			3.服务器推送：还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。

## Http缓存

强制缓存：收到请求，看是否有缓存，直接使用缓存。

对比缓存：收到请求，看是否有缓存，然后向服务器询问缓存是否可用，可用则返回304；如果不匹配，表示资源有更新，服务器会将新数据和新的缓存标识一起返回到浏览器

**Cache-Control**
Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。
private:             客户端可以缓存
public:              客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）
max-age=xxx:   缓存的内容将在 xxx 秒后失效
no-cache:          需要使用对比缓存来验证缓存数据（后面介绍）

## HTTP请求的GET方法和POST方法的区别？

GET与POST是我们常用的两种HTTP Method，二者之间的区别:
(1). 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；
(2). 从请求参数形式上看，GET请求的数据会附在URL之后，以?分割URL和传输数据，参数之间以&相连。
(3). 就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。
(4). 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。

## 转发和重定向的区别：

1、浏览器URL的地址栏不变。重定向：浏览器URL的地址栏改变；
2、转发是服务器行为，重定向是客户端行为；
3、转发是浏览器只做了一次访问请求。重定向是浏览器做了至少两次的访问请求的；
4、转发2次跳转之间传输的信息不会丢失，重定向2次跳转之间传输的信息会丢失（request范围）。

## HTTP无状态？session和cookie怎么实现的

HTTP无状态协议，是指协议对事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传。
Cookie和Session都是客户端与服务器之间保持状态的解决方案，cookie是在http请求头的cookie字段中，而session保存在服务端。

## session和cookie的区别

1、session 在服务器端，cookie 在客户端
2、Session的实现常常依赖于Cookie机制，若浏览器禁用Cookie的话，可以通过 URL重写机制将sessionid传回服务器。
3、Cookie有大小限制，Session没有大小限制。
4、Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session用于保存在服务器端，相对更加安全；

## 常见状态码及原因短语

100：客户端应该继续发送剩余的请求
200：服务器已成功处理了请求。 204:表示服务器接收到的请求已经处理完毕，但是服务器不需要返回响应体.
300：提供操作列表供请求者选择 301 : 永久性转移 302 ：暂时性转移（这2个重定向） 304 ：文件未更新
400：语法错误 	401：发送的请求需要通过 HTTP 认证   403：拒绝请求  404：客户端所访问的页面不存在 
500 ：服务器内部错误       502：错误网关    503 ： 服务不可用，稍等	504：网关超时

## TCP\UDP的区别

![img](md\66.png)

TCP是面向连接的，UDP是无连接的；
TCP是可靠的，UDP是不可靠的；
TCP只支持点对点通信，UDP支持一对一、一对多、多对多的通信模式；
TCP是面向字节流的，UDP是面向报文的；

## 对于可靠性，TCP通过以下方式进行保证：

##### 应答机制：

当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；

##### 超时重发：

当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；

##### 流量控制：

TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。 

![img](md\67.jpg)

## UDP实现TCP可靠传输

1. 添加seq/ack机制，实现应答机制
2. 添加发送和接收缓冲区，实现流量控制
3. 设置定时器，实现超时重传机制

## TCP的粘包和UDP的丢包

### TCP粘包

现象：一个socket端口接受到send(500)+send(1000)，但receive时候可能出现800+700，需要应用层出处理流不对的问题。因为tcp只保证可靠，不保证字节流不合并。

## 网线断了TCP连接情况

处于半连接状态；客户端发送心跳包多次收不到服务器的响应时可终止此TCP连接，而服务端可监测客户端的心跳包，若在一定时间间隔内未收到任何来自客户端的心跳包则可以终止此TCP连接。

## ARQ停止等待协议

发送方每发送一帧就暂停，等待应答（ACK）到来。收方收到数据帧后发送应答（ACK）帧给发送方，发送方再发送下一个数据帧。

## 连续ARQ协议

连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。
缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。

## 地址解析协议 ARP

**ARP用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址**。

工作流程：通信时必须要有mac地址，在syn报文到达网络层时，进行一次ARP请求和回复过程，然后封装mac到报文中，且缓存起来。

那么为什么我们需要IP地址呢？

因为如果我们只用MAC地址的话，我们会发现路由器需要记住每个MAC地址所在的子网是哪一个（不然一次收到数据包的时候路由器都要重新满世界地去找这 个MAC地址的位置）。而世界上有248个MAC地址，这就意味着朗使我们给每个MAC地址只 留1字节的储存空间，每个路由器也需要256TB的内存！这显然是不可能实现的。 这就是我们需要IP地址的原因了。和MAC不同的是，IP地址是和地域相关的。对于位于同一个子网上的设，我们给他们分配的IP地址前缀都是一样的。这个前缀就像邮政编码一样。这样，路由器通过IP地址的前缀就能知道这个设备在哪个子网上了。现在，路由器只需要记住每个子网的位置 即可，大大减少了路由器所需要的内存。 既然甲地址不能去掉，

那么能不能去掉MAC地址呢？

1.主要原因是ip地址是变化的，没有mac地址容易被盗用身份

2.IPV4地址有限，只有40亿个，因此需要NAT技术。NAT技术是使用内网IP的，内网IP是根据MAC地址分配的，路由器会保存一个MAC地址映射表。

## 拥塞控制

TCP的拥塞控制采用了四种算法，即 慢开始 、拥塞避免 、快重传 和 快恢复。

送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。

快重传：没收到确认，连续发送3个回去；快恢复：拥塞窗口大小减半

流量控制控制端到端的速率，而拥塞控制控制全局网络的速率。

## OSI参考模型的分为哪几层，每层的功能？

![äºå±ä½ç³»ç»æ](md\68.png)

####  物理层（比特流）

物理层负责用光纤把两台计算机连起来，然后在计算机之间通过高低电频来传送0,1这样的电信号。

####  数据链路层（帧）

规定0,1电信号协议。

#### 网络层（数据包）

在网络层，进行dns解析和arp广播增加作为通信目的地的 MAC 地址和ip地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。

#### 传输层（段）

接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。

#### 应用层（报文）

HTTP、DNS

## 在浏览器中输入网址到显示出页面的整个过程？

(1) 输出包含域名的网址 (2) 浏览器向DNS请求解析域名对应的IP地址 (3) 域名系统DNS解析出域名对应的IP地址 (4) 浏览器与该服务器建立TCP连接 (5) 浏览器发送HTTP请求 (6) 服务器通过HTTP响应把页面文件发送给浏览器 (7) TCP连接释放 (8) 浏览器解释文件，并显示

## ping指令的整个过程

ping通知系统建立一个固定格式的ICMP请求数据包，根据ip地址获取对方mac地址，若本机无缓存，则进行一次ARP请求和回复过程，然后封装mac到报文中，机器B收到这个数据帧后，先检查目的地址，和本机MAC地址对比符合，接收。

## DNS 解析

浏览器缓存、本地缓存-》

![](md\101.png)

CDN网络是在用户和服务器之间增加Cache层（较近网络服务器），主要是通过接管DNS实现，将用户的请求引导到Cache上获得源服务器的数据，从而降低网络的访问的速度。

## http协议与tcp/ip协议有什么区别？http三次握手画图说明。

​	IP想象成一种高速公路，它允许其它协议在上面行驶并找到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等

![ä¸æ¬¡æ¡æ](md\72.png)

![åæ¬¡æ¥æ](md\73.png)

## 为什么连接的时候是三次握手，关闭的时候却是四次握手？

TCP是可靠的，TCP 的可靠连接是靠序号来达成的。假如只有两次握手，只有服务器对客户端的序号做了确认，但客户端却没有对服务器的序号做确认，不能保证传输的可靠性。

释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接。因为还有必要的数据需要处理，所以服务器先返回 ACK 确认收到报文，经过 CLOSE-WAIT 阶段准备好释放连接之后，才能返回 FIN 释放连接报文。

## 三次握手的作用

确认双方的接受能力、发送能力是否正常。

如果是 HTTPS 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成。

## ACCEPT()

三次握手之后，tcp连接会加入到accept队列。accept()会从队列中取一个连接返回，若队列为空，则阻塞。

## time_wait和close_wait有什么区别？

Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
TIME_WAIT 是主动关闭链接时形成的, 主要是防止最后一个ACK丢失和影响到新的TCP连接。

## 为什么是2msl？（报文最大生存时间）

可靠的实现双方终止连接，防止最后一个报文丢失

如果客户端不等待2MSL直接进行关闭，前一次的连接的数据还在网络中

## DDOS攻击

原因：客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

预防：限制同时打开SYN半链接的数目；缩短SYN半链接的Time out 时间

## SQL注入

原因：SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

预防：对sql语句预编译，使用正则表达式过滤传入的参数

## XSS攻击

原因：用 <script type="text/javascript"></script> 包起来发送的回帖中

预防：正则表达式过滤，将script关键字获取到；

## CSRF攻击

通过xss创建一个自动提交的表格，冒充用户进行一些操作。

预防：请求头加token字段

## CDN（内容分发网络）

可以用来分发直播、点播、网页静态文件、小文件等等。在美国上传的图片，我们也同样保存一份在香港，如果在深圳访问的时候，我们就直接使用香港的数据即可，这样子速度就会快非常多！

# 操作系统

是一种系统软件，负责管理协调计算机硬件和软件资源以及为用户和程序提供服务

## 操作系统的四个特性

并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。

共享：互斥共享方式，同时共享方式

虚拟：虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。

异步：多个进程走走停停，以不可预知的速度向前推进，这就是进程的异步性。

同步：各个进程遵循一定的先后顺序

## 并发和并行

并发:指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。

常考易混概念- --并行:指两个或多个事件在同一时刻同时发生。

## 上下文切换

上下文切换(Context Switch)是一种将CPU资源从一个线程分配给另一个线程的机制。

## 大内核、微内核

![1574478626805](md\74.png)

内核就是企业的管理层，负责-一些重要的工作。只有管理层才能执行特权指令，普通员工只能
执行非特权指令。用户态、核心态之间的切换相当于普通员工和管理层之间的工作交接
大内核:企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高;缺点是组织
结构混乱，难以维护。
微内核:随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方
便维护;缺点是效率低。

## 守护、僵尸、孤儿进程的概念

守护进程：守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。
僵尸进程：僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。
孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，这些子进程称为孤儿进程。

## 请分别简单说一说进程和线程以及它们的区别。

​    1.进程要分配一大部分的内存，而线程只需要分配一部分栈就可以了.
​    2.一个程序至少有一个进程,一个进程至少有一个线程.
​    3.进程是资源分配的最小单位，线程是程序执行的最小单位。
​    4.一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行.
​    5.进程与进程之间的交互通过TCP/IP的端口来实现，线程的通信就比较简单，有一大块共享的内存，只要大家的指针是同一个就可以看到各自的内存。
​    操作系统真正运行的是一个个的线程，而进程可以看做是线程的一个容器。

## 线程同步的方式有哪些？

互斥 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
信号量 semaphore：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
事件(信号)Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

## 进程同步

1. 临界区
3. 信号量
4. 管程（类似Synchronized）：每次仅允许一个进程在管程内执行

## 进程间的通信的几种方式

管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；

信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；

消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；

共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；

信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；

套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

## 线程有几种状态？进程有哪几种状态？

就绪状态，运行状态，阻塞状态
创建、就绪、运行、阻塞、等待、时间等待和消亡。

## 进程调度和进程切换

狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，
也可能是另一个进程，后一种情况就需要进程切换）
进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。

## 进程调度算法

### 批处理操作系统

先来先服务：有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行

短作业优先 ：如果一直有短作业到来，那么长作业永远得不到调度。

最短剩余时间优先 ：任务剩余时间越短，则不管长短作业，先执行。

### 交互式操作系统

时间片轮转：进程可以执行一个时间片，当时间片用完时，将它送往就绪队列的末尾。

优先级调度：为每个进程分配一个优先级，按优先级进行调度。

多级反馈队列：多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。

## 中断、系统调用、库函数

#### 中断

外部中断一般是指由计算机外设发出的中断请求
内部中断是指因硬件出错
软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序。
一、当中断发生时，CPU立即进入核心态.
二、当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理
三、对于不同的中断信号，会进行不同的处理

#### 系统调用

系统调用是通向操作系统本身的接口，是面向底层硬件的。通过系统调用，可以使得
用户态运行的进程与硬件设备(如：CPU、磁盘、打印机等)进行交互。
用户进程需要发生系统调用时，内核将调用内核相关函数来实现（如：sys_read()、
sys_write()、sys_fork()）。用户程序不能直接调用这些函数，这些函数运行在内核态，
CPU 通过软中断切换到内核态开始执行内核系统调用函数。
系统调用和中断的关系就在于，当进程发出系统调用申请的时候，会产生一个软中
断。产生这个软中断以后，系统会去对这个软中断进行处理，这个时候进程就处于核心态
了。

#### 库函数

库函数是把函数放到库里，供别人使用的一种方式。【系统调用是为了方便使用操作
系统的接口，而库函数则是为了人们编程的方便。】

## 用户态、核心态之间的切换

“用户态>核心态” 是通过中断实现的。并且中断是唯一途径。
“核心态<用户态”的切换是通过执行一个特权指令，将程序状态字(PSW) 的标志位设置为“用户态”

## 操作系统的用户态和核心态切换条件以及为什么要切换

当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。

## 内存分配分为连续分配和非连续分配管理两种

#### 内存连续分配

1、单一连续分配：分为系统区和用户区，系统区供给操作系统使用，用户区供给用户使
用，内存中永远只有一道程序。
2、固定分区分配：最简单的一种多道程序管理方式，它将用户内存空间划分为若干个固定
大小的区域，每个分区只装入一道作业。【方法一：分区大小相等；方法二：分区大小不
等，划分为含有多个较小的分区，适量的中等分区及少量的大分区】
3、动态分区分配：又称为可变分区分配，是一种动态划分内存的方法。这种分区方法不预
先将内存划分，而是在进程装入内存时，根据进程的大小动态的建立分区，并使分区的大
小正好适合进程的需要。因此系统中分区的大小和数目是可变的。

#### 非连续分配

分页就是将这些段，例如代码段分成均匀的小块，然后这些给这些小块编号，然后就可以放到内存中去，由于编号了的，所以也不怕顺序乱

分段就是将一个程序分成代码段，数据段，堆栈段什么的

## 分段和分页有什么区别（内存管理）？

分页对用户不可见，分段对用户可见。

分页的地址空间是一维的（地址），分段的地址空间是二维的（段名和地址）。

页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制

页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定。

## 操作系统的虚拟内存

在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。虚拟内存就是在硬盘上面划分出一个区域来充当内存,和物理内存共同来处理信息。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。

## 操作系统页置换的算法

FIFO先进先出算法：在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；
LRU算法：根据使用时间到现在的长短来判断；
OPT算法：丢弃最晚使用的数据
CLOCK算法：循环队列，如果访问为为0，则访问位+1或置换；如果为1，则跳过；如果都为1，全部变为0。

## 磁盘调度算法

先来先服务：按照磁盘请求的顺序进行调度。

最短寻道时间优先：优先调度与当前磁头所在磁道距离最近的磁道。

电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

## 硬链接和软链接

文件共享的两种方式：软链接相当于快捷方式（link文件指向程序），硬链接不同用户的文件表有指向同一程序的指针。

![img](md\75.jpg)

## 死锁的概念:

两个或多个线程无限期的阻塞、相互等待的一种状态。

” Jconsole查看死锁“

死锁原因： 
竞争资源：请求同一有限资源的进程数多于可用资源数
进程推进顺序非法：进程执行中，请求和释放资源顺序不合理，如资源等待链

## 死锁产生的必要条件：

互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；
占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；
非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放
循环等待：若干进程之间形成一种头尾相接的环形等待资源关系

## 死锁处理策略：

预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；
避免死锁：在资源的动态分配中，防止系统进入可能产生死锁的状态-如银行家算法
检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程
解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。

## 经典的线程同步问题（哲学家，生产消费）

生产者消费者问题
哲学家进餐问题
银行家算法

```
Allocation　　　Max　　　Available
 　　 ＡＢＣＤ　　  ＡＢＣＤ　　ＡＢＣＤ
 P1   ００１４　　  ０６５６　　１５２０　
 P2　 １４３２　　  １９４２　
 P3　 １３５４　  　１３５６
 P4 　１０００　　  １７５０
```